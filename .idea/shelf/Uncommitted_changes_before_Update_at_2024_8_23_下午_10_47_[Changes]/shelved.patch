Index: API/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from rest_framework.response import Response\r\nfrom .models import Posts, Comments\r\nfrom .serializers import PostSerializer, UserSerializer, CommentSerializer\r\nfrom rest_framework import viewsets\r\nfrom rest_framework.authentication import TokenAuthentication\r\nfrom rest_framework.permissions import IsAuthenticated, IsAuthenticatedOrReadOnly\r\nfrom django.contrib.auth.models import User\r\nfrom rest_framework.filters import SearchFilter\r\nfrom rest_framework import status\r\n# Create your views here.\r\n\r\n\r\n# the viewset class inculde all CRUD methods\r\nclass PostViewset(viewsets.ModelViewSet):\r\n\r\n    queryset = Posts.objects.all()\r\n    serializer_class = PostSerializer\r\n    # adding required permissions to this views to restrict unauthenticated user\r\n    permission_classes = [IsAuthenticatedOrReadOnly]\r\n    # for the authentication, can access only when you request with token\r\n    authentication_classes = (TokenAuthentication,)\r\n    # for the searching\r\n    filter_backends = [SearchFilter]\r\n    search_fields = ['title', 'description', 'author__username']\r\n\r\n    # overwrite the create method to automatically add the current user into \"author\" field\r\n    def perform_create(self, serializer):\r\n        # get the user id with token\r\n        # user_id = Token.objects.get(key=self.request.auth.key).user_id\r\n        # get user name with user id\r\n        # user = User.objects.get(id=user_id).username\r\n        # fill user name into the author field to show which user posted/edited it\r\n        serializer.save(author=self.request.user)\r\n\r\n    # overwrite the partial update method (one way)\r\n    def partial_update(self, request, *args, **kwargs):\r\n        postObject = self.get_object()\r\n        data = request.data\r\n\r\n        # use new data if there is data from title field in front, otherwise use the old data\r\n        postObject.title = data.get(\"title\", postObject.title)\r\n        postObject.description = data.get(\r\n            \"description\", postObject.description)\r\n        postObject.cover = data.get(\"cover\", postObject.cover)\r\n        try:\r\n            author = User.objects.get(username=data[\"username\"])\r\n            postObject.author = author\r\n        except KeyError:\r\n            pass\r\n        postObject.save()\r\n\r\n        # send request context to get the absolute url of 'cover' image\r\n        serializer = PostSerializer(postObject, context={\"request\": request})\r\n\r\n        return Response(serializer.data)\r\n\r\n    # # overwrite the partial update method (another way)\r\n    # def update(self, request, *args, **kwargs):\r\n    #     postObject = self.get_object()\r\n    #     data = request.data\r\n\r\n    #     # change partial to True changing only provided fields\r\n    #     serializer = self.get_serializer(\r\n    #         postObject, data=request.data, partial=True)\r\n    #     serializer.is_valid(raise_exception=True)\r\n    #     self.perform_update(serializer)\r\n\r\n    #     return Response(serializer.data)\r\n\r\n\r\n# the viewset class for users\r\nclass UserViewSet(viewsets.ModelViewSet):\r\n    queryset = User.objects.all()\r\n    serializer_class = UserSerializer\r\n\r\n    def update(self, request, pk=None):\r\n        response = {'message': 'Update function is not offered in this path.'}\r\n        return Response(response, status=status.HTTP_403_FORBIDDEN)\r\n\r\n    def partial_update(self, request, pk=None):\r\n        response = {'message': 'Update function is not offered in this path.'}\r\n        return Response(response, status=status.HTTP_403_FORBIDDEN)\r\n\r\n    def destroy(self, request, pk=None):\r\n        response = {'message': 'Delete function is not offered in this path.'}\r\n        return Response(response, status=status.HTTP_403_FORBIDDEN)\r\n\r\n# the viewset class for comments\r\n\r\n\r\nclass CommentViewset(viewsets.ModelViewSet):\r\n\r\n    queryset = Comments.objects.all()\r\n    serializer_class = CommentSerializer\r\n    # adding required permissions to this views to restrict unauthenticated user\r\n    permission_classes = [IsAuthenticatedOrReadOnly]\r\n    # for the authentication, can access only when you request with token\r\n    authentication_classes = (TokenAuthentication,)\r\n\r\n    # overwrite the create method to automatically add the current user into \"author\" field\r\n    def perform_create(self, serializer):\r\n        serializer.save(author=self.request.user)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/API/views.py b/API/views.py
--- a/API/views.py	(revision 9312c1c8908f34ddf82abb50712875aa122ca722)
+++ b/API/views.py	(date 1724445871669)
@@ -23,13 +23,8 @@
     filter_backends = [SearchFilter]
     search_fields = ['title', 'description', 'author__username']
 
-    # overwrite the create method to automatically add the current user into "author" field
+    # overwrite the perform_create to automatically add the current user into "author" field
     def perform_create(self, serializer):
-        # get the user id with token
-        # user_id = Token.objects.get(key=self.request.auth.key).user_id
-        # get user name with user id
-        # user = User.objects.get(id=user_id).username
-        # fill user name into the author field to show which user posted/edited it
         serializer.save(author=self.request.user)
 
     # overwrite the partial update method (one way)
@@ -49,24 +44,23 @@
             pass
         postObject.save()
 
+        # add or remove user's likes into many-to-many field
+        # check if current user has already liked this post
+        # try:
+        #   userlikes = User.objects.get(username=data["userlikes"])
+        #   if data["userlikes"] in postObject.userlikes.all():
+        #   if postObject.userlikes.filter(username=data["userlikes"]).exists():
+        #       postObject.userlikes.add(userlikes)
+        #   else:
+        #       postObject.userlikes.remove(userlikes)
+        # except KeyError:
+        #   pass
+
         # send request context to get the absolute url of 'cover' image
         serializer = PostSerializer(postObject, context={"request": request})
 
         return Response(serializer.data)
 
-    # # overwrite the partial update method (another way)
-    # def update(self, request, *args, **kwargs):
-    #     postObject = self.get_object()
-    #     data = request.data
-
-    #     # change partial to True changing only provided fields
-    #     serializer = self.get_serializer(
-    #         postObject, data=request.data, partial=True)
-    #     serializer.is_valid(raise_exception=True)
-    #     self.perform_update(serializer)
-
-    #     return Response(serializer.data)
-
 
 # the viewset class for users
 class UserViewSet(viewsets.ModelViewSet):
@@ -85,9 +79,8 @@
         response = {'message': 'Delete function is not offered in this path.'}
         return Response(response, status=status.HTTP_403_FORBIDDEN)
 
+
 # the viewset class for comments
-
-
 class CommentViewset(viewsets.ModelViewSet):
 
     queryset = Comments.objects.all()
Index: API/note/views_note.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>''' 5. using ModelViewSet,the easist way to bulid Rest API in backend\r\n(The ModelViewSet inherits from/pack GenericAPIView)\r\n\r\nfrom .models import Posts\r\nfrom .serializers import PostSerializer\r\nfrom rest_framework import viewsets\r\n\r\n# the class inculde all CRUD methods\r\nclass PostViewset(viewsets.ModelViewSet):\r\n\r\n    queryset = Posts.objects.all()\r\n    serializer_class = PostSerializer\r\n'''\r\n\r\n\r\n''' 4. using GenericViewSet and mixins, make coed concised \r\n(The GenericViewSet inherits from/pack GenericAPIView)\r\n\r\nfrom .models import Posts\r\nfrom .serializers import PostSerializer\r\nfrom rest_framework import mixins\r\nfrom rest_framework import viewsets\r\n\r\n# the class inculde all CRUD methods\r\nclass PostViewset(viewsets.GenericViewSet, mixins.ListModelMixin,\r\n                  mixins.CreateModelMixin, mixins.RetrieveModelMixin,\r\n                  mixins.UpdateModelMixin, mixins.DestroyModelMixin):\r\n\r\n    queryset = Posts.objects.all()\r\n    serializer_class = PostSerializer\r\n\r\n'''\r\n\r\n\r\n''' 3. using viewsets and Router in urls.py, all CRUD methods can be contained in one viewsets class \r\n# (The ViewSet inherits from/pack APIView)\r\n\r\nfrom .models import Posts\r\nfrom .serializers import PostSerializer\r\nfrom rest_framework import viewsets\r\nfrom django.shortcuts import get_object_or_404\r\nfrom rest_framework.response import Response\r\nfrom rest_framework import status\r\n\r\n# the class inculde all CRUD methods\r\nclass PostViewset(viewsets.ViewSet):\r\n\r\n    def list(self, request):\r\n        posts = Posts.objects.all()\r\n        serializer = PostSerializer(posts, many=True)\r\n        return Response(serializer.data)\r\n\r\n    def create(self, request):\r\n        serializer = PostSerializer(data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        else:\r\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n    def retrieve(self, request, pk=None):\r\n        queryset = Posts.objects.all()\r\n        thePost = get_object_or_404(queryset, pk=pk)\r\n        # thePost = Posts.objects.get(pk=pk) # should handle the not found response\r\n        serializer = PostSerializer(thePost)\r\n        return Response(serializer.data)\r\n\r\n    def update(self, request, pk=None):\r\n        thePost = Posts.objects.get(pk=pk)\r\n        serializer = PostSerializer(thePost, data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        else:\r\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n    def destroy(self, request, pk=None):\r\n        thePost = Posts.objects.get(pk=pk)\r\n        thePost.delete()\r\n        return Response(status=status.HTTP_204_NO_CONTENT)\r\n'''\r\n\r\n\r\n''' 2. using GenericAPIView and mixins, make coed concised \r\n# (GenericAPIView inherits from/pack the APIView)\r\n\r\nfrom .models import Posts\r\nfrom .serializers import PostSerializer\r\nfrom rest_framework import generics, mixins \r\n\r\n# the class to read and create (no post is specified)\r\nclass PostList(generics.GenericAPIView, mixins.ListModelMixin, mixins.CreateModelMixin):\r\n\r\n    # from GenericAPIView\r\n    queryset = Posts.objects.all()\r\n    serializer_class = PostSerializer\r\n\r\n    # from mixins\r\n    def get(self, request):\r\n        return self.list(request)\r\n\r\n    def post(self, request):\r\n        return self.create(request)\r\n\r\n\r\n# the class to get the detail or modify or delete the corresponding post\r\nclass PostDetail(generics.GenericAPIView, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin):\r\n    \r\n    # from GenericAPIView\r\n    queryset = Posts.objects.all()\r\n    serializer_class = PostSerializer\r\n\r\n    # from mixins\r\n    def get(self, request, pk):\r\n        return self.retrieve(request, pk=pk)\r\n\r\n    def put(self, request, pk):\r\n        return self.update(request, pk=pk)\r\n\r\n    def delete(self, request, pk):\r\n        return self.destroy(request, pk=pk)\r\n\r\n#################################### or even more concise (without mixins)... ####################################\r\nclass SnippetList(generics.ListCreateAPIView):\r\n    queryset = Snippet.objects.all()\r\n    serializer_class = SnippetSerializer\r\n\r\n\r\nclass SnippetDetail(generics.RetrieveUpdateDestroyAPIView):\r\n    queryset = Snippet.objects.all()\r\n    serializer_class = SnippetSerializer\r\n'''\r\n\r\n\r\n''' 1.2. using class API \r\n# (APIView inherits from/pack View in Django)\r\n\r\nfrom .models import Posts\r\nfrom .serializers import PostSerializer\r\nfrom rest_framework.decorators import APIView\r\nfrom rest_framework.response import Response\r\nfrom rest_framework import status\r\n\r\n# the name of functions in calss have to be exactly get, post, put, delete\r\n\r\n# the class to read and create (no post is specified)\r\nclass PostList(APIView):\r\n\r\n    # read all data from database\r\n    def get(self, request):\r\n        posts = Posts.objects.all()\r\n        serializer = PostSerializer(posts, many=True)\r\n        return Response(serializer.data)\r\n\r\n    # store new data into database\r\n    def post(self, request):\r\n        serializer = PostSerializer(data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        else:\r\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n\r\n# the class to get the detail or modify or delete the corresponding post\r\nclass PostDetail(APIView):\r\n\r\n    def getThePost(self, pk):\r\n        try:\r\n            # get the corresponding data\r\n            return Posts.objects.get(pk=pk)\r\n        except Posts.DoesNotExist:\r\n            # not found\r\n            return Response(status=status.HTTP_404_NOT_FOUND)\r\n\r\n    # read the the corresponding data in database\r\n    def get(self, request, pk):\r\n        thePost = self.getThePost(pk)\r\n        serializer = PostSerializer(thePost)\r\n        return Response(serializer.data)\r\n\r\n    # modify the corresponding data in database\r\n    def put(self, request, pk):\r\n        thePost = self.getThePost(pk)\r\n        serializer = PostSerializer(thePost, data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data)\r\n        else:\r\n            # 400 means bad request error\r\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n    # delete the corresponding data in database\r\n    def delete(self, request, pk):\r\n        thePost = self.getThePost(pk)\r\n        thePost.delete()\r\n        return Response(status=status.HTTP_204_NO_CONTENT)\r\n'''\r\n\r\n\r\n''' 1.1. using functional API \r\n# (api_view inherits from/pack View in Django)\r\n\r\nfrom .models import Posts\r\nfrom .serializers import PostSerializer\r\nfrom rest_framework.decorators import api_view \r\nfrom rest_framework.response import Response\r\nfrom rest_framework import status\r\n\r\n\r\n# the function to read and create (no post is specified)\r\n@api_view(['GET', 'POST'])\r\ndef PostList(request):\r\n\r\n    # read all data from database\r\n    if request.method == 'GET':\r\n        # read all data from database\r\n        posts = Posts.objects.all()\r\n        serializer = PostSerializer(posts, many=True)\r\n        return Response(serializer.data)\r\n\r\n    # store new data into database\r\n    elif request.method == 'POST':\r\n        # store new data into database\r\n        serializer = PostSerializer(data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        else:\r\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n\r\n# the function to get the detail or modify or delete the corresponding post\r\n@api_view(['GET', 'PUT', 'DELETE'])\r\ndef PostDetail(request, pk):\r\n    try:\r\n        # get the corresponding data\r\n        thePost = Posts.objects.get(pk=pk)\r\n    except Posts.DoesNotExist:\r\n        # not found\r\n        return Response(status=status.HTTP_404_NOT_FOUND)\r\n\r\n    # read the the corresponding data in database\r\n    if request.method == 'GET':\r\n        serializer = PostSerializer(thePost)\r\n        return Response(serializer.data)\r\n\r\n    # modify the corresponding data in database\r\n    elif request.method == 'PUT':\r\n        # store modified data to the corresponding post in database\r\n        serializer = PostSerializer(thePost, data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data)\r\n        else:\r\n            # 400 means bad request error\r\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n    # delete the corresponding data in database\r\n    elif request.method == 'DELETE':\r\n        thePost.delete()\r\n        return Response(status=status.HTTP_204_NO_CONTENT)\r\n\r\n'''\r\n\r\n\r\n''' 0. using Django View without any rest framework\r\nhttps://www.django-rest-framework.org/tutorial/1-serialization/\r\n'''\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/API/note/views_note.py b/API/note/views_note.py
--- a/API/note/views_note.py	(revision 9312c1c8908f34ddf82abb50712875aa122ca722)
+++ b/API/note/views_note.py	(date 1724445871668)
@@ -10,6 +10,68 @@
 
     queryset = Posts.objects.all()
     serializer_class = PostSerializer
+
+    # overwrite the create method
+    # def create(self, request, *args, **kwargs):
+    #     data = request.data
+    #     newThing = Post.objects.create(field=data["filed"],....)
+    #     newThing.save()
+    #     serializer = theSerializer(newThing)
+    #     return Response(serializer.data)
+
+    # overwrite the perform_create to automatically add the current user into "author" field
+    def perform_create(self, serializer):
+        # get the user id with token
+        # user_id = Token.objects.get(key=self.request.auth.key).user_id
+        # get user name with user id
+        # user = User.objects.get(id=user_id).username
+        # fill user name into the author field to show which user posted/edited it
+        serializer.save(author=self.request.user)
+
+
+
+    # overwrite the partial update method (one way)
+    def partial_update(self, request, *args, **kwargs):
+        postObject = self.get_object()
+        data = request.data
+
+        # use new data if there is data from title field in front, otherwise use the old data
+        postObject.title = data.get("title", postObject.title)
+        postObject.description = data.get("description", postObject.description)
+        postObject.cover = data.get("cover", postObject.cover)
+        try:
+            # don't have the field of username, this will be passed 
+            author = User.objects.get(username=data["username"])
+            postObject.author = author
+        except KeyError:
+            pass
+        postObject.save()
+
+        # add or remove user's likes into many-to-many field
+        # check if current user has already liked this post 
+        # if data["userlikes"] in postObject.userlikes.all(): 
+        if postObject.userlikes.filter(username=data["userlikes"]).exists():
+            postObject.userlikes.add(data["userlikes"])
+        else:
+            postObject.userlikes.remove(data["userlikes"])
+
+        # send request context to get the absolute url of 'cover' image
+        serializer = PostSerializer(postObject, context={"request": request})
+
+        return Response(serializer.data)
+
+    # # overwrite the partial update method (another way)
+    def update(self, request, *args, **kwargs):
+        postObject = self.get_object()
+        data = request.data
+
+        # change partial to True changing only provided fields
+        serializer = self.get_serializer(
+            postObject, data=request.data, partial=True)
+        serializer.is_valid(raise_exception=True)
+        self.perform_update(serializer)
+
+        return Response(serializer.data)
 '''
 
 
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 9312c1c8908f34ddf82abb50712875aa122ca722)
+++ b/README.md	(date 1724445871669)
@@ -1,0 +1,32 @@
+# Blog App Django Backend
+
+A REST API built with Django, Django Rest Framework, and Python for the blog application.
+ 
+Github link of Blog App React Frontend: https://github.com/chrisnumber49/React-Blog-App-Frontend
+
+## Project Screen Shots
+<img src="https://github.com/chrisnumber49/DjangoBlogAppBackend/blob/master/screen%20shot/demo1.PNG" width="700" > 
+<img src="https://github.com/chrisnumber49/DjangoBlogAppBackend/blob/master/screen%20shot/demo2.PNG" width="700" > 
+<img src="https://github.com/chrisnumber49/DjangoBlogAppBackend/blob/master/screen%20shot/demo3.PNG" width="700" > 
+
+## Installation and Setup Instructions
+
+Clone down this repository. You will need `Django` and `Django Rest Framework` installed globally on your machine.  
+
+Installation: `pip install Django` and `pip install djangorestframework`
+
+Creating new migrations: `python manage.py makemigrations`
+
+Applying migrations: `python manage.py migrate`
+
+To Start Server: `python manage.py runserver`  
+ 
+To Visit App: `localhost:8000/`
+
+## Reflection 
+
+This is my first side project of integrating full stack development with React frontend and Django backend. In the Django backend, I built a REST API for blog application, in the database we have 3 Models mapped to each single table: **Post**, **User**, and **Comment**. In the **Post** Model, the author field has many to one relationship with **User** Model; Identically, **Comment** Model also has many to one relationship with **User** Model and **Post** Model in its author and post field, that means one single post will contain an author of the post and also might have few post comments inside. Through the setting of serializers and URL routers, we can send requests to the specific URL to implement the CRUD operation and search any post with a specific keyword from the frontend interface.
+
+I started this project by using the command `django-admin startproject` to create the boilerplate of the project, then create a new app with the command `python manage.py startapp`, two dependencies were installed, `pillow` is for for saving and serving static files to the client, and `django-cors-headers` is to allow resources to be accessed on other domains.
+
+In the backend REST API of this side project, I learned about the concept of various components that make up REST framework, and understood each wrapper that Django Rest Framework provides for Views including function-based API Views, class-based API Views, GenericAPIView, viewsets, GenericViewSet and ModelViewSet, and lastly knew the Authentication and Permissions to restrict who can access the data.
